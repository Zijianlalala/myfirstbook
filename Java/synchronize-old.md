# 同步相关
有关多线程的问题

## 参考博客
![从ReentrantLock的实现看AQS的原理及应用](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)

![Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)

![不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)

![synchronized 实现原理](https://xiaomi-info.github.io/2020/03/24/synchronized/)
## 概念
编发编程的特性
1. 原子性
2. 可见性。当一个线程对共享变量进行了修改，那么其他线程都是立即可以看到修改后的最新值。`volatile`
3. 有序性


## `sleep`和`wait`的区别
`sleep`是使当前运行的线程停止执行指定的时间，该线程不会放弃任何管程的拥有权。

`wait`是使当前运行的线程等待，直到其他的线程调用这个对象的`notifyAll()`或者`notify()`方法；或者中断此线程；或者等待超过指定的时间。总之，`wait`和`notify`用于多线程协调运行。

另外使用`wait`时值得注意的几点
1. 使用`wait`之前的判断条件要用`while(condition)`而非`if(condition)`，因为线程会偶尔从等待状态激活，也就是需要再次获得`this`锁
2. 获得到同步锁后需要再检查一遍条件，因为条件的数量有限，可能会别的线程用掉。
3. 在调用`wait`和`notify`之前，必须拥有锁，当一个线程在`this.wait()`上等待时，它就会释放`this`锁。

## i++是线程不安全的操作
测试了两个线程的同时写的情况不会出错，测试100个线程对同一变量同时进行i++操作时，会出错。

出错的原因是`i++`这条语句不具备原子性。
```
getfield // 读取变量
iadd // 加1
putfield // 写回变量
```
应该将这三条语句上锁，才能解决。

## synchronized关键字
### 用法
1. 作用于实例方法。使用`synchronized`修饰方法，可以把整个方法变为同步代码块，`synchronized`方法加锁的对象是`this`。
2. 作用于静态方法。如果用`synchronized`修饰静态方法，那么锁住的对象是该类的`Class`实例，所以相当于该类的一个全局锁。
3. 作用于对象实例。

### 同步原理
底层原理属于JVM层面。`synchronized`同步语句块的实现是通过两个指令`monitorenter`和`monitorexit`。这两个指令维护`monitor`。

对于同步方法，常量池中多了个`ACC_SYNCHRONIZED`标识符。在方法执行期间，其他任何线程都无法再获得同一个`monitor`对象。

### 同步概念
> 对象在内存中的布局分为三块区域：对象头、实例数据和对其填充。
> 对象头又主要包括
> 1. `Mark word`存储对象运行时的数据。哈希码、锁状态等。
> 2. `Class Pointer`指向它的类元数据的指针。

锁状态的升级流程：无锁->偏向锁->轻量级锁->重量级锁

当线程访问同步快并获取偏向锁的处理流程
1. 检查锁对象的mark word中的线程id
2. 如果为空，则设置CAS替换为当前线程id。如果替换失败，撤销。
3. 如果不空，且该线程id是本线程则获得锁。否则撤销偏向锁。

多个线程竞争偏向锁导致其升级为轻量级锁。

### 锁优化
#### 自旋锁
当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否释放，而不是进入挂起或睡眠状态。
#### 自适应自旋锁

### 可重入锁
JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，叫做可重入锁。

## CAS(compare and swap)
比较并替换，是一种实现并发算法时常用的技术。

在多线程环境下，使用自增操作会导致数据不一致现象。因为自增操作不是原子性操作。所有要把自增操作替换为`AtomicInteger.getAndIncrement()`。而这个方法最终调用的是`compareAndSwapInt`方法。

### 思想
三个参数
1. 当前内存值V
2. 旧的预期值A
3. 即将更新的值B
   
当且仅当V==A时，将内存值修改为B，返回true，否则自旋。

## volatile关键字
被`volatile`关键字修饰的变量是共享且不稳定的，每次使用它都要到主存中的读取，保证变量的可见性。另外还有防止JVM的指令重排列的作用。

### 与synchronized的区别
* `volatile`关键字是线程同步的轻量级实现，只能用于变量。而`synchronized`可以修饰方法以及代码块。
* `volatile`主要用于解决共享变量在多个线程之间的可见性。而`synchronized`主要解决多个线程之前访问资源的同步性。


## ThreadLocal
管理每个线程的私有变量。它可以在一个线程中传递同一个对象。

## 线程池
简单地说，线程池维护了若干个线程，没有任务的时候，这些线程都处于等待状态。若有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程处理。

Java标准库提供了`ExecutorService`接口表示线程池。推荐使用`ThreadPoolExecutor`是创建线程池，而非`Executors`。

### 好处
1. 降低资源消耗
2. 提高响应速度
3. 提高线程的可管理性




### Runnable和Callable
1. Runnable没有返回值，Callable有返回值。

**Future**用来获取Callable的返回结果

**CompletableFuture**针对**Future**做了改进，可以传入回调对象。当异步任务完成或发生异常时，自动调用回调方法。以及拥有串行和并行的特性。

